var letters = {
	'A': [
		[, 1],
		[1, , 1],
		[1, , 1],
		[1, 1, 1],
		[1, , 1]
	],
	'B': [
		[1, 1],
		[1, , 1],
		[1, 1, 1],
		[1, , 1],
		[1, 1]
	],
	'C': [
		[1, 1, 1],
		[1],
		[1],
		[1],
		[1, 1, 1]
	],
	'D': [
		[1, 1],
		[1, , 1],
		[1, , 1],
		[1, , 1],
		[1, 1]
	],
	'E': [
		[1, 1, 1],
		[1],
		[1, 1, 1],
		[1],
		[1, 1, 1]
	],
	'F': [
		[1, 1, 1],
		[1],
		[1, 1],
		[1],
		[1]
	],
	'G': [
		[, 1, 1],
		[1],
		[1, , 1, 1],
		[1, , , 1],
		[, 1, 1]
	],
	'H': [
		[1, , 1],
		[1, , 1],
		[1, 1, 1],
		[1, , 1],
		[1, , 1]
	],
	'I': [
		[1, 1, 1],
		[, 1],
		[, 1],
		[, 1],
		[1, 1, 1]
	],
	'J': [
		[1, 1, 1],
		[, , 1],
		[, , 1],
		[1, , 1],
		[1, 1, 1]
	],
	'K': [
		[1, , , 1],
		[1, , 1],
		[1, 1],
		[1, , 1],
		[1, , , 1]
	],
	'L': [
		[1],
		[1],
		[1],
		[1],
		[1, 1, 1]
	],
	'M': [
		[1, 1, 1, 1, 1],
		[1, , 1, , 1],
		[1, , 1, , 1],
		[1, , , , 1],
		[1, , , , 1]
	],
	'N': [
		[1, , , 1],
		[1, 1, , 1],
		[1, , 1, 1],
		[1, , , 1],
		[1, , , 1]
	],
	'O': [
		[1, 1, 1],
		[1, , 1],
		[1, , 1],
		[1, , 1],
		[1, 1, 1]
	],
	'P': [
		[1, 1, 1],
		[1, , 1],
		[1, 1, 1],
		[1],
		[1]
	],
	'Q': [
		[0, 1, 1],
		[1, , , 1],
		[1, , , 1],
		[1, , 1, 1],
		[1, 1, 1, 1]
	],
	'R': [
		[1, 1],
		[1, , 1],
		[1, , 1],
		[1, 1],
		[1, , 1]
	],
	'S': [
		[1, 1, 1],
		[1],
		[1, 1, 1],
		[, , 1],
		[1, 1, 1]
	],
	'T': [
		[1, 1, 1],
		[, 1],
		[, 1],
		[, 1],
		[, 1]
	],
	'U': [
		[1, , 1],
		[1, , 1],
		[1, , 1],
		[1, , 1],
		[1, 1, 1]
	],
	'V': [
		[1, , , , 1],
		[1, , , , 1],
		[, 1, , 1],
		[, 1, , 1],
		[, , 1]
	],
	'W': [
		[1, , , , 1],
		[1, , , , 1],
		[1, , , , 1],
		[1, , 1, , 1],
		[1, 1, 1, 1, 1]
	],
	'X': [
		[1, , , , 1],
		[, 1, , 1],
		[, , 1],
		[, 1, , 1],
		[1, , , , 1]
	],
	'Y': [
		[1, , 1],
		[1, , 1],
		[, 1],
		[, 1],
		[, 1]
	],
	'Z': [
		[1, 1, 1, 1, 1],
		[, , , 1],
		[, , 1],
		[, 1],
		[1, 1, 1, 1, 1]
	],
	'0': [
		[1, 1, 1],
		[1, , 1],
		[1, , 1],
		[1, , 1],
		[1, 1, 1]
	],
	'1': [
		[0,1,0],
		[1,1,0],
		[0,1,0],
		[0,1,0],
		[1,1,1]
	],
	'2': [
		[1,1,1],
		[0,0,1],
		[1,1,1],
		[1,0,0],
		[1,1,1]
	],
	'3':[
		[1,1,1],
		[0,0,1],
		[1,1,1],
		[0,0,1],
		[1,1,1]
	],
	'4':[
		[1,0,1],
		[1,0,1],
		[1,1,1],
		[0,0,1],
		[0,0,1]
	],
	'5':[
		[1,1,1],
		[1,0,0],
		[1,1,1],
		[0,0,1],
		[1,1,1]
	],
	'6':[
		[1,1,1],
		[1,0,0],
		[1,1,1],
		[1,0,1],
		[1,1,1]
	],
	'7':[
		[1,1,1],
		[0,0,1],
		[0,0,1],
		[0,0,1],
		[0,0,1]
	],
	'8':[
		[1,1,1],
		[1,0,1],
		[1,1,1],
		[1,0,1],
		[1,1,1]
	],
	'9':[
		[1,1,1],
		[1,0,1],
		[1,1,1],
		[0,0,1],
		[1,1,1]
	],
	' ': [
		[, ,],
		[, ,],
		[, ,],
		[, ,],
		[, ,]
	],
	'.': [
		[, ,],
		[, ,],
		[, ,],
		[, ,],
		[0,1,0]
	],
	'<': [
		[0,0,1],
		[0,1,0],
		[1,0,0],
		[0,1,0],
		[0,0,1]
	],
	'0': [
		[1,1,1],
		[1,0,1],
		[1,0,1],
		[1,0,1],
		[1,1,1]
	],
	'2': [
		[1,1,1],
		[0,0,1],
		[0,1,1],
		[1,0,0],
		[1,1,1]
	],
	'3': [
		[1,1,1],
		[0,0,1],
		[1,1,0],
		[0,0,1],
		[1,1,1]
	]
};

let theSeed = 451;

function setPixelated(context){
    context['imageSmoothingEnabled'] = false;
    context['mozImageSmoothingEnabled'] = false;
    context['oImageSmoothingEnabled'] = false;
    context['webkitImageSmoothingEnabled'] = false;
    context['msImageSmoothingEnabled'] = false;
}

function mkcanv( width, height, args = {} ) {
	args.appendDOM = args.appendDOM != undefined ? args.appendDOM : false;

	let canv = document.createElement('canvas');
	canv.width = width;
	canv.height = height;

	if ( args.appendDOM ) {
		document.body.appendChild( canv );
	}

	return canv;
}

function hexToRgb(hex) {
	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
	  r: parseInt(result[1], 16),
	  g: parseInt(result[2], 16),
	  b: parseInt(result[3], 16)
	} : null;
}

function rgbToHex(r, g, b) {
	return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);
}

function palshift( dyntexArgs, ctx, palshiftData ) {
	let newImgData = ctx.getImageData(0, 0, dyntexArgs.w, dyntexArgs.h);
	let data = newImgData.data;
	for ( let i = 0; i < data.length; i += 4 ) {
		for ( let j = 0; j < palshiftData.length; j++ ) {
			let palshiftEntry = palshiftData[j];
			let frgb = hexToRgb( palshiftEntry[0] );
			let trgb = hexToRgb( palshiftEntry[1] );

			if ( data[i] == frgb.r && data[i + 1] == frgb.g && data[i + 2] == frgb.b ) {
				data[i] = trgb.r;
				data[i + 1] = trgb.g;
				data[i + 2] = trgb.b;
			}
		}
	}

	ctx.putImageData( newImgData, 0, 0 );
}

function closestColor(pixel, palette) {
    var index = 0;
    var minimumDistance = Number.MAX_VALUE;
    for (var i = 0; i < palette.length; i++) {
        var rgb1 = hexToRgb(pixel);
        var rgb2 = hexToRgb(palette[i]);
        var distance = 0;
        distance += (rgb1.r - rgb2.r) * (rgb1.r - rgb2.r);
        distance += (rgb1.g - rgb2.g) * (rgb1.g - rgb2.g);
        distance += (rgb1.b - rgb2.b) * (rgb1.b - rgb2.b);
        //console.log("distance: " + distance + ", minDistance: " + minimumDistance);
        if (distance < minimumDistance) {
            index = i;
            minimumDistance = distance;
        }
    }
    return index;
}

function recolorImage(data, palette, preserveTransparency) {

    var amountReplaces = 0;
    var amountData = data.length;

    for (var i = 0; i < amountData; i += 4) {
        var alpha = data[i + 3];

		if (alpha > 0) {
            var hex = rgbToHex(data[i], data[i + 1], data[i + 2]);
            var closestPaletteIndex = closestColor(hex, palette);
            //console.log(palette[closestPaletteIndex]);
            var paletteRGB = hexToRgb(palette[closestPaletteIndex]);

            // check if we need to replace the color
            if (data[i] == paletteRGB.r && data[i + 1] == paletteRGB && data[i + 2] == paletteRGB.b) {
                // ignore
            } else {
                data[i] = paletteRGB.r;
                data[i + 1] = paletteRGB.g;
                data[i + 2] = paletteRGB.b;
                if (!preserveTransparency) {
                    data[i + 3] = 255;
                }

                amountReplaces++;
            }
        }

    }

    return {
        data: data,
        amountReplaces: amountReplaces
    };
};

function dist(x1, y1, x2, y2) {
	var a = x1 - x2;
	var b = y1 - y2;

	return Math.hypot(a, b);
}

function rad(deg) {
	return deg * Math.PI / 180;
}

function drawText(ctx, posX, posY, string, size, fillColor = '#fff') {
	var needed = [];
	string = string.toUpperCase(); // because I only did uppercase letters
	for (var i = 0; i < string.length; i++) {
		var letter = letters[string.charAt(i)];
		if (letter) { // because there's letters I didn't do
			needed.push(letter);
		}
	}

	ctx.fillStyle = fillColor;
	var currX = posX;
	for (i = 0; i < needed.length; i++) {
		letter = needed[i];
		var currY = posY;
		var addX = 0;
		for (var y = 0; y < letter.length; y++) {
			var row = letter[y];
			for (var x = 0; x < row.length; x++) {
				if (row[x]) {
					ctx.fillRect(currX + x * size, currY, size, size);
				}
			}
			addX = Math.max(addX, row.length * size);
			currY += size;
		}
		currX += size + addX;
	}
}

function drawTri( ctx, pts, fillStyle ) {
	for ( let i = 0; i < 1; i++ ) {
		ctx.beginPath();

		ctx.moveTo( pts[0].x, pts[0].y );

		ctx.lineTo( pts[1].x, pts[1].y );
		ctx.lineTo( pts[2].x, pts[2].y );
		ctx.closePath();
		ctx.fillStyle = fillStyle;
		ctx.fill();
	}
}

function ellip( ctx, x, y, rx, ry, fillStyle = null, strokeStyle = null, lineWidth = 1 ) {
	for ( let i = 0; i < 1; i++ ) {
		ctx.beginPath();
		ctx.ellipse(
			x,
			y,
			rx,
			ry,
			0,
			0,
			2 * Math.PI,
			false
		);
		if ( fillStyle != null ) {
			ctx.fillStyle = fillStyle;
			ctx.fill();
		}

		if ( strokeStyle != null ) {
			ctx.strokeStyle = strokeStyle;
			ctx.lineWidth = lineWidth;
			ctx.stroke();
		}
	}
}

function circle( ctx, x, y, r, fillStyle = null, strokeStyle = null, lineWidth = 1 ) {
	for ( let i = 0; i < 1; i++ ) {
		ellip( ctx, x, y, r, r, fillStyle, strokeStyle, lineWidth );
	}
}

function rect( ctx, x, y, w, h, fillStyle = null, strokeStyle = null, lineWidth = 1 ) {
	for ( let i = 0; i < 1; i++ ) {
		if ( fillStyle != null ) {
			ctx.fillStyle = fillStyle;
			ctx.fillRect(x, y, w, h);
		}

		if ( strokeStyle != null ) {
			ctx.strokeStyle = strokeStyle;
			ctx.lineWidth = lineWidth;
			ctx.strokeRect(0, 0, w, h);
		}
	}
}

function rint(min, max) {
	min = Math.ceil(min);
	max = Math.floor(max);
	return Math.floor(Math.random() * (max - min + 1)) + min;
}

function rf(min, max) {
    return Math.random() * (max - min) + min;
}

let noise = (function(){
	let _noise = { };
	
	function G(x, y, z) {
		this.x = x; this.y = y; this.z = z;
	}
	
	G.prototype.dot2 = function(x, y) {
		return this.x*x + this.y*y;
	};
	
	g3 = [new G(1,1,0),new G(-1,1,0),new G(1,-1,0),new G(-1,-1,0),
				new G(1,0,1),new G(-1,0,1),new G(1,0,-1),new G(-1,0,-1),
				new G(0,1,1),new G(0,-1,1),new G(0,1,-1),new G(0,-1,-1)];
	
	let p = [151,160,137,91,90,15,
		131,13,201,95,96,53,194,233,7,225,140,36,103,30,69,142,8,99,37,240,21,10,23,
		190, 6,148,247,120,234,75,0,26,197,62,94,252,219,203,117,35,11,32,57,177,33,
		88,237,149,56,87,174,20,125,136,171,168, 68,175,74,165,71,134,139,48,27,166,
		77,146,158,231,83,111,229,122,60,211,133,230,220,105,92,41,55,46,245,40,244,
		102,143,54, 65,25,63,161, 1,216,80,73,209,76,132,187,208, 89,18,169,200,196,
		135,130,116,188,159,86,164,100,109,198,173,186, 3,64,52,217,226,250,124,123,
		5,202,38,147,118,126,255,82,85,212,207,206,59,227,47,16,58,17,182,189,28,42,
		223,183,170,213,119,248,152, 2,44,154,163, 70,221,153,101,155,167, 43,172,9,
		129,22,39,253, 19,98,108,110,79,113,224,232,178,185, 112,104,218,246,97,228,
		251,34,242,193,238,210,144,12,191,179,162,241, 81,51,145,235,249,14,239,107,
		49,192,214, 31,181,199,106,157,184, 84,204,176,115,121,50,45,127, 4,150,254,
		138,236,205,93,222,114,67,29,24,72,243,141,128,195,78,66,215,61,156,180];
	// To remove the need for index wrapping, double the permutation table length
	perm = new Array(512);
	gP = new Array(512);
	
	// This isn't a very good seeding function, but it works ok. It supports 2^16
	// different seed values. Write something better if you need more seeds.
	_noise.seed = function(seed) {
		if(seed > 0 && seed < 1) {
		// Scale the seed out
		seed *= 65536;
		}
	
		seed = Math.floor(seed);
		if(seed < 256) {
		seed |= seed << 8;
		}
	
		for( i = 0; i < 256; i++) {
		v=0;
		if (i & 1) {
			v = p[i] ^ (seed & 255);
		} else {
			v = p[i] ^ ((seed>>8) & 255);
		}
	
		perm[i] = perm[i + 256] = v;
		gP[i] = gP[i + 256] = g3[v % 12];
		}
	};
	
	_noise.seed(0);
	
	// ##### Perlin noise stuff
	
	function fade(t) {
		return t*t*t*(t*(t*6-15)+10);
	}
	
	function lerp(a, bs, t) {
		return (1-t)*a + t*bs;
	}
	
	// 2D Perlin Noise
	_noise.perlin2 = function(x, y) {
		// Find unit grid cell containing point
		X = Math.floor(x), Y = Math.floor(y);
		// Get relative xy coordinates of point within that cell
		x = x - X; y = y - Y;
		// Wrap the integer cells at 255 (smaller integer period can be introduced here)
		X = X & 255; Y = Y & 255;
	
		// Calculate noise contributions from each of the four corners
		n00 = gP[X+perm[Y]].dot2(x, y);
		n01 = gP[X+perm[Y+1]].dot2(x, y-1);
		n10 = gP[X+1+perm[Y]].dot2(x-1, y);
		n11 = gP[X+1+perm[Y+1]].dot2(x-1, y-1);
		
		// Compute the fade curve value for x
		u = fade(x);
	
		// Interpolate the four results
		return lerp(
			lerp(n00, n10, u),
			lerp(n01, n11, u),
		fade(y));
	};

	return _noise;
})(this);
noise.seed( theSeed );

function isObject(o) {
	return o instanceof Object && o.constructor === Object;
}

function clamp(val, min, max) {
	return val < min ? min : ( val > max ? max : val );
}

function cull(obj) {
	if ( obj.x < -64 || obj.x > 224 + 64 ||
		obj.y < -64 || obj.y > 288 + 64 ) {
		return true;
	}
	return false;
}

function collision( a, b ) {
	a.origin = a.origin != undefined ? a.origin : { x: 0, y: 0 };
	b.origin = b.origin != undefined ? b.origin : { x: 0, y: 0 };

	let aX = a.x - a.origin.x;
	let aY = a.y - a.origin.y;
	let bX = b.x - b.origin.x;
	let bY = b.y - b.origin.y;

	if ( aX < bX + b.dw &&
	aX + a.dw > bX &&
	aY < bY + b.dh &&
	aY + a.dh > bY ) {
		return true;
	}
	return false;
}

function damage( target, source ) {
	if ( target.hp != -1 ) {
		if ( target.hp - source.power > 0 ) {
			target.hp -= source.power;

			target.showHit = true;
		}
		else {
			if ( target.hp > 0 && target.onDestroy ) {
				target.onDestroy();
			}

			target.hp = 0;
			target.destr = true;
		}
	}
}

function squaredPolar(point, centre) {
    return [
        Math.atan2(point[1]-centre[1], point[0]-centre[0]),
        (point[0]-centre[0])**2 + (point[1]-centre[1])**2 // Square of distance
    ];
}

// Main algorithm:
function polySort(points) {
    // Get "centre of mass"
    let centre = [points.reduce((sum, p) => sum + p[0], 0) / points.length,
                  points.reduce((sum, p) => sum + p[1], 0) / points.length];

    // Sort by polar angle and distance, centered at this centre of mass.
    for (let point of points) point.push(...squaredPolar(point, centre));
    points.sort((a,b) => a[2] - b[2] || a[3] - b[3]);
    // Throw away the temporary polar coordinates
    for (let point of points) point.length -= 2; 
}

function pen(ctx, x, y, col) {
	ctx.fillStyle = col;
	ctx.fillRect(x, y, 1, 1);
}

function dyntex( args ) {
	console.log('starting dyntex', args);
	let canvtex = mkcanv( args.w, args.h, {
		appendDOM: true
	} );
	let ctxtex = canvtex.getContext( '2d' );
	setPixelated( ctxtex );

	if ( args.bg != undefined ) {
		ctxtex.fillStyle = args.bg;
		ctxtex.fillRect(0, 0, canvtex.width, canvtex.height);
	}

	if ( args.render ) {
		console.log('rendering...');
		args.render( ctxtex );
	}

	let huesArray = [];
	for ( const property in args.hues ) {
		huesArray.push( args.hues[property] );
	}
	console.log(huesArray);
	let recolor = recolorImage( ctxtex.getImageData(0, 0, canvtex.width, canvtex.height).data, huesArray, false );
	console.log('RECOLOR', recolor);
	var newRecolorData = new ImageData(recolor.data, canvtex.width, canvtex.height);
	ctxtex.putImageData( newRecolorData, 0, 0 );
	
	if ( args.palshift ) {
		console.log('palshifting...');
		palshift( args, ctxtex, args.palshift );
	}

	console.log('finished dyntex');

	return {
		canv: canvtex
	};
}

class Spr {
	constructor( args ) {
		this.type = args.type;
		this.depth = args.depth != undefined ? args.depth : 0;
		this.plyr = args.plyr;
		this.img = args.img;
		this.x = args.x;
		this.y = args.y;
		this.canCull = args.canCull != undefined ? args.canCull : true;
		this.perceivedHeight = args.perceivedHeight != undefined ? args.perceivedHeight : 32;
		this.frame = args.frame;
		this.showHitDelay = 10;
		this.showHitTick = 0;
		this.showHit = false;

		this.imgs = args.imgs;

		this.vis = true;
		this.isPlaying = this.img != undefined ? ( this.img.anim ? true : false ) : false;
		this.animDelay = args.animDelay;
		this.animTick = args.animTick;

		this.scaleX = args.scaleX != undefined ? args.scaleX : 1;
		this.scaleY = args.scaleY != undefined ? args.scaleY : 1;

		if ( args.scale != undefined ) {
			this.scaleX = args.scale;
			this.scaleY = args.scale;
		}

		this.angle = 0;

		this.groundProj = args.groundProj != undefined ? args.groundProj : false;
		this.speed = args.speed;
		this.velX = args.velX != undefined ? args.velX : 0;
		this.velY = args.velY != undefined ? args.velY : 0;
		this.points = args.points !== undefined ? args.points : 0;
		this.life = args.life != undefined ? args.life : -1;
		this.hpInit = args.hp != undefined ? args.hp : -1;
		this.hp = this.hpInit;
		this.power = args.power != undefined ? args.power : 0;
		this.isFriendly = args.isFriendly != undefined ? args.isFriendly : true;
		this.destr = false;

		this.w = 0;
		this.h = 0;
		this.dyntex = null;
		if ( this.img != undefined ) {
			if ( this.img.dynrender != undefined ) {
				if ( this.img.dynrender ) {
					this.dyntex = this.img.dyntexes[rint(0, this.img.dyntexes.length - 1)]; // pick dynamic texture
					this.w = this.dyntex.canv.width;
					this.h = this.dyntex.canv.height;

					this.dyntex.shadCanv = null;
					if ( this.img.dynrender.hs != undefined ) {
						if ( this.img.dynrender.hs ) {
							this.dyntex.shadCanv = mkcanv( this.img.dynrender.w, this.img.dynrender.h );
							let shadCtx = this.dyntex.shadCanv.getContext( '2d' );
				
							let imgData = this.dyntex.canv.getContext('2d').getImageData(0, 0, this.img.dynrender.w, this.img.dynrender.h);
							let data = imgData.data;
							for ( let i = 0; i < data.length; i += 4 ) {
								let hasPixel = data[i + 3] > 0 ? true : false;
				
								if ( hasPixel ) {
									data[i] = 0;
									data[i + 1] = 0;
									data[i + 2] = 0;
								}
							}
				
							shadCtx.putImageData( imgData, 0, 0 );
						}
					}
				}
			}
			else {
				this.w = this.img.el.width;
				this.h = this.img.el.height;
			}

			if ( this.img.anim ) {
				this.w = this.img.fw;
				this.h = this.img.fh;
			}
		}

		this.dw = this.w * this.scaleX;
		this.dh = this.h * this.scaleY;

		this.origin = args.origin != undefined ? args.origin : { x: 0, y: 0 };

		this.shadow = null;
		if ( this.dyntex != null ) {
			if ( this.dyntex.shadCanv != null ) {
				this.shadow = spr( {
					img: {
						fw: this.img.fw,
						fh: this.img.fh,
						anim: this.img.anim,
						el: this.dyntex.shadCanv
					},
					x: this.x,
					y: this.y,
					animTick: this.animTick,
					animDelay: this.animDelay,
					origin: {
						x: this.w / 2,
						y: this.h / 2
					},
					scaleX: this.scaleX * 0.4,
					scaleY: this.scaleY * 0.4,
				} );
			}
		}
	}

	baseUpdate() {
		this.x += this.velX;
		this.y += this.velY;

		if ( this.perceivedHeight < 0 ) {
			this.perceivedHeight = 0;
		}

		if ( this.shadow != null ) {
			this.shadow.x = this.x;
			this.shadow.y = this.y - ( this.perceivedHeight * 1.5 );
			this.shadow.angle = this.angle;
		}

		if ( this.showHit ) {
			if ( this.showHitTick < this.showHitDelay ) {
				this.showHitTick++;
			}
			else {
				this.vis = true;
				this.showHit = false;
				this.showHitTick = 0;
			}
		}

		if ( this.life != -1 ) {
			if ( this.life > 0 ) {
				this.life--;
			}
			else {
				this.destr = true;
			}
		}
	}

	update() {
		this.baseUpdate();
	}

	baseRender( ctx ) {
		this.baseUpdate();

		if ( this.shadow ) {
			this.shadow.update();
		}

		if ( this.update ) {
			this.update();
		}

		if ( this.showHit ) {
			this.vis = false;
		}

		if ( this.vis ) {
			if ( this.shadow ) {
				this.shadow.render( ctx );
			}

			if ( this.img ) {
				ctx.translate(Math.round(this.x), Math.round(this.y) );
				ctx.scale(this.scaleX, this.scaleY);
				ctx.rotate(rad(this.angle));

				let img = this.img.el;

				if ( this.img.dynrender != undefined ) {
					if ( this.img.dynrender ) {
						img = this.dyntex.canv;
					}
				}

				if ( this.img.anim ) {
					if ( this.isPlaying ) {
						if ( this.animTick < this.animDelay ) {
							this.animTick++;
						}
						else {
							if ( this.frame < this.img.frames - 1 ) {
								this.frame++;
							}
							else {
								this.frame = 0;
							}

							this.animTick = 0;
						}
					}

					ctx.drawImage( img, this.frame * this.img.fw, 0, this.img.fw, this.img.fh, -this.origin.x, -this.origin.y, this.w, this.h );
				}
				else {
					ctx.drawImage( img, -this.origin.x, -this.origin.y, this.w, this.h );
				}
				ctx.setTransform(1, 0, 0, 1, 0, 0);
			}
		}
	}

	render( ctx ) {
		this.baseRender( ctx );
	}
}

class Player extends Spr {
	constructor( args ) {
		super( args );
		args.type = 'player';
	}
}

class Consumable extends Spr {
	constructor( args ) {
		super( args );
	}
}

class Spinner extends Spr {
	constructor( args ) {
		super( args );
		this.origin = { x: 8, y: 8 };
		this.hasCharged = false;
	}

	update() {
		this.angle += 10;

		if ( this.y > this.plyr.y - 64 ) {
			this.velY = 3;

			if ( ! this.hasCharged ) {
				if ( this.x < this.plyr.x ) {
					this.velX = 5;
				}
				else if ( this.x > this.plyr.x ) {
					this.velX = -5;
				}

				this.hasCharged = true;
			}
		}
	}
}

class Drone extends Spr {
	constructor( args ) {
		super( args );
		this.maxChaseSpeed = 3;
		this.chaseSpeed = 0.5;
	}

	update() {
		if ( dist( this.x, this.y, this.plyr.x, this.plyr.y ) < 128 ) {
			this.isPlaying = true;

			if ( this.chaseSpeed < this.maxChaseSpeed ) {
				this.chaseSpeed += 0.01;
			}

			let dx = this.plyr.x - this.x;
			let dy = this.plyr.y - this.y;
			let angle = Math.atan2(dy, dx);
			let targetVelX = this.chaseSpeed * Math.cos( angle );
			let targetVelY = this.chaseSpeed * Math.sin( angle );

			if ( this.velX < targetVelX ) {
				this.velX += 0.05;
			}
			else {
				this.velX -= 0.05;
			}

			if ( this.velY < targetVelY ) {
				this.velY += 0.05;
			}
			else {
				this.velY -= 0.05;
			}
		}
	}
}

class GAA extends Spr {
	constructor( args ) {
		super( args );
		this.canShoot = true;
	}
}

class GAA_Large_Hub extends Spr {
	constructor( args ) {
		super( args );
		this.buildings = [];
	}
}

class BigBaddie extends Spr {
	constructor( args ) {
		super( args );
		this.state = 'move_forward';

		this.canSpawnGun = false;
		this.hasSpawnedGun = false;

		this.buildings = [];
	}

	update() {
		switch ( this.state ) {
			case 'move_forward': {
				if ( this.y < 144/2 ) {
					this.velY = 0.15;
				}
				else {
					this.velY = 0;
					this.canSpawnGun = true;
				}
				break;
			}
		}
	}
}

function spr(args) {
	return new Spr(args);
}

window.addEventListener( 'DOMContentLoaded', () => {
	let canvas = document.getElementById( 'c' );
	canvas.width = 224;
	canvas.height = 288;
	console.log('test', canvas);

	let ctx = canvas.getContext( '2d' );
	setPixelated( ctx );

	let ctrlCanv = mkcanv( 224, 96 );
	ctrlCanv.id = 'ctrl';
	let ctrlCtx = ctrlCanv.getContext( '2d' );
	setPixelated( ctx );

	let hues = null;
	let imgs = null;

	// init
	let surfaceZoom = 10;
	let stage = 0;
	let state = 0;
	let stageSeeds = [
		451,
		981,
		463,
		928,
		126,
		521
	];
	let timeoutIds = [];
	let tiles = [];
	let parts = [];
	let consumables = [];
	let player = null;
	let playerCrosshair = null;
	let pslot = null;
	let pslotItem = null;
	let score = 0;
	let maxLives = 3;
	let lives = maxLives; 
	let maxLasersPlzr = 3;
	let maxLasersFireballs = 3;
	let maxLasersMissiles = 1;
	let maxLasers = maxLasersPlzr;
	let lasers = maxLasers;
	let lasersTick = 0;
	let lasersDelay = 10;
	let maxBombs = 1;
	let bombs = maxBombs;
	let bombsTick = 0;
	let bombsDelay = 30;
	let hasPowerUp = false;
	let puTimeLeft = 0;
	let menuPosPoint = {
		x: rint(0, canvas.width),
		y: rint(128, 200)
	};
	let forcePrimaryFire = false;
	let forcePrimaryFireTimeLeft = 10;
	let forceSecondaryFire = false;
	let forceSecondaryFireTimeLeft = 10;
	let enemies = [];
	let projs = [];
	let canNaturalSpawn = true;
	let canSpawnBoss = false;
	let hasSpawnedBoss = false;
	let elapsed = 0;
	let currentGeneratedY = 0;
	let tileMoveDelta = 0;
	let mainMenuOptions = [
		'PLAY',
		'HIGH SCORES'
	];
	let mainMenuOptionSelected = 0;
	let highScoreOptions = [
		'BACK',
		'CLEAR SCORES'
	];
	let highScoreOptionSelected = 0;
	let highScoreConfirmationOptions = [
		'BACK',
		'CLEAR SCORES'
	];
	let highScoreConfirmationOptionSelected = 0;

	let consumableItems = {
		pu_fireball: {
			life: 300,
			callbacks: {
				pickup: () => {
					maxLasers = maxLasersFireballs;
				}
			}
		},
		pu_missile: {
			life: 200,
			callbacks: {
				pickup: () => {
					maxLasers = maxLasersMissiles;
				}
			}
		}
	};



	let keys = {};
	let keyConfig = {
		W: 'KeyW',
		S: 'KeyS',
		A: 'KeyA',
		D: 'KeyD',
		PFIRE: 'Space',
		SFIRE: 'ShiftLeft'
	};

	window.addEventListener( 'keydown', (e) => {
		if ( ! keys[e.code] ) {
			switch ( e.code ) {
				case 'Enter': { // enter
					if ( state == 0 ) {
						if ( mainMenuOptionSelected == 0 ) { // play
							state = 1;
							reset( {
								type: 'hard'
							} );
						}
						else if ( mainMenuOptionSelected == 1 ) { // high scores
							state = 2;
						}
					}
					else if ( state == 2 ) {
						if ( highScoreOptionSelected == 0 ) { // back
							state = 0;
						}
						else if ( highScoreOptionSelected == 1 ) { // clear scores
							state = 3;
						}
					}
					else if ( state == 3 ) {
						if ( highScoreConfirmationOptionSelected == 0 ) { // back to high scores
							state = 2;
						}
						else if ( highScoreConfirmationOptionSelected == 1 ) { // clear high scores
							let store = JSON.parse( localStorage.getItem( 'stella_proelium' ) );
							store = ( store != undefined && store != null ) ? store : {};
							store.highscores = store.highscores != undefined ? store.highscores : [];

							store.highscores.length = 0;

							console.log('saving ', store);

							localStorage.setItem( 'stella_proelium', JSON.stringify( store ) );
						}
					}
					break;
				}

				case 'KeyW': { // W
					if ( state == 0 ) {
						if ( mainMenuOptionSelected - 1 >= 0 ) {
							mainMenuOptionSelected--;
						}
						else {
							mainMenuOptionSelected = mainMenuOptions.length - 1;
						}
					}
					else if ( state == 2 ) {
						if ( highScoreOptionSelected - 1 >= 0 ) {
							highScoreOptionSelected--;
						}
						else {
							highScoreOptionSelected = highScoreOptions.length - 1;
						}
					}
					else if ( state == 3 ) {
						if ( highScoreConfirmationOptionSelected + 1 < highScoreConfirmationOptions.length ) {
							highScoreConfirmationOptionSelected++;
						}
						else {
							highScoreConfirmationOptionSelected = 0;
						}
					}
					break;
				}

				case 'KeyS': { // S
					if ( state == 0 ) {
						if ( mainMenuOptionSelected + 1 < mainMenuOptions.length ) {
							mainMenuOptionSelected++;
						}
						else {
							mainMenuOptionSelected = 0;
						}
					}
					else if ( state == 2 ) {
						if ( highScoreOptionSelected + 1 < highScoreOptions.length ) {
							highScoreOptionSelected++;
						}
						else {
							highScoreOptionSelected = 0;
						}
					}
					else if ( state == 3 ) {
						if ( highScoreConfirmationOptionSelected + 1 < highScoreConfirmationOptions.length ) {
							highScoreConfirmationOptionSelected++;
						}
						else {
							highScoreConfirmationOptionSelected = 0;
						}
					}
					break;
				}
			}
		}

		keys[e.code] = true;
	} );

	window.addEventListener( 'keyup', (e) => {
		keys[e.code] = false;
	} );

	( function() {
		let contentData = loadContent();
		hues = contentData.hues;
		imgs = contentData.imgs;

		init();

		rect( ctrlCtx, 0, 0, ctrlCanv.width, ctrlCanv.height, hues.LT_GRY );

		gameloop();
	} )();



	function changeItem( name ) {
		console.log('changing item to ' + name);

		if ( consumableItems[name].callbacks != undefined ) {
			if ( consumableItems[name].callbacks.pickup != undefined ) {
				consumableItems[name].callbacks.pickup();
			}
		}

		pslotItem = spr( {
			img: imgs[name],
			x: 16,
			y: canvas.height - (24 + 16),
			scale: 1.5
		} );

		hasPowerUp = true;
		if ( consumableItems[name].life != undefined ) {
			puTimeLeft = consumableItems[name].life;
		}
	}

	function loseItem() {
		delete pslotItem;
		pslotItem = null;

		maxLasers = maxLasersPlzr;
	}

	function reset( args ) {
		tiles.length = 0;
		parts.length = 0;
		consumables.length = 0;
		player = null;
		playerCrosshair = null;
		pslot = null;
		pslotItem = null;
		score = 0;
		maxLives = 3;
		maxLasersPlzr = 3;
		maxLasersFireballs = 1;
		maxLasersMissiles = 1;
		maxLasers = maxLasersPlzr;
		lasers = maxLasers;
		lasersTick = 0;
		lasersDelay = 10;
		maxBombs = 1;
		bombs = maxBombs;
		bombsTick = 0;
		bombsDelay = 30;
		hasPowerUp = false;
		puTimeLeft = 0;
		enemies.length = 0;
		projs.length = 0;
		elapsed = 0;
		tileMoveDelta = 0;
		mainMenuOptionSelected = 0;

		for ( let i = 0; i < timeoutIds.length; i++ ) {
			clearTimeout( timeoutIds[i] );
			timeoutIds.splice( i, 1 );
			i--;
		}

		init();

		switch ( args.type ) {
			case 'soft': {
				canSpawnBoss = false;
				hasSpawnedBoss = false;
				break;
			}

			case 'hard': {
				currentGeneratedY = 0;
				lives = maxLives;
				stage = 0;
				canNaturalSpawn = true;
				canSpawnBoss = false;
				hasSpawnedBoss = false;
				break;
			}
		}
	}

	function init() {
		for ( let x = 0; x < 14; x++ ) {
			for ( let y = -1; y < 18; y++ ) {
				generateTile(x, y, x, y);
			}
		}

		player = new Player({
			x: canvas.width * 0.5,
			y: canvas.height * 0.5,
			origin: { x: 8, y: 8 },
			img: imgs.plyr,
			hp: 1,
			animDelay: 7
		});
		player.onDestroy = () => {
			if ( state == 1 ) {
				let store = JSON.parse( localStorage.getItem( 'stella_proelium' ) );
				store = ( store != undefined && store != null ) ? store : {};
				store.highscores = store.highscores != undefined ? store.highscores : [];

				store.highscores.push( score );
				
				store.highscores.sort((a, b) => b - a);
				localStorage.setItem( 'stella_proelium', JSON.stringify( store ) );
				
				if ( lives > 0 ) {
					lives--;

					let timeoutId = setTimeout( function() {
						reset({
							type: 'soft'
						});
					}.bind( this ), 3000 );
					timeoutIds.push( timeoutId );
				}
				else {
					let timeoutId = setTimeout( function() {
						state = 0;
						reset( {
							type: 'very hard'
						} );
					}.bind( this ), 3000 );
					timeoutIds.push( timeoutId );
				}
			}
			else {
				let timeoutId = setTimeout( function() {
					reset({
						type: 'soft'
					});
				}.bind( this ), 3000 );
				timeoutIds.push( timeoutId );
			}
		};

		playerCrosshair = spr( {
			x: player.x,
			y: player.y - 48,
			origin: { x: 8, y: 8 },
			frame: 0,
			img: imgs.crosshair
		} );
		playerCrosshair.isPlaying = false;

		// primary slot
		pslot = spr( {
			x: 16,
			y: canvas.height - (24 + 16),
			img: imgs.pslot
		} );
	}

	function update() {

		if ( hasPowerUp ) {
			if ( puTimeLeft > 0 ) {
				puTimeLeft--;
			}
			else {
				loseItem();
				hasPowerUp = false;
			}
		}

		if ( forcePrimaryFire == true ) {
			if ( forcePrimaryFireTimeLeft > 0 ) {
				forcePrimaryFireTimeLeft--;
			}
			else {
				forcePrimaryFire = false;
				forcePrimaryFireTimeLeft = rint(10, 60);
			}
		}

		if ( forceSecondaryFire == true ) {
			if ( forceSecondaryFireTimeLeft > 0 ) {
				forceSecondaryFireTimeLeft--;
			}
			else {
				forceSecondaryFire = false;
				forceSecondaryFireTimeLeft = 10;
			}
		}


		if ( player.hp > 0 ) {
			let playerSpeed = 2;

			if ( state == 1 ) {
				let vx = ( ( keys[keyConfig.A] ? -1 : 0 ) + ( keys[keyConfig.D] ? 1 : 0 ) ) * playerSpeed;
				let vy = ( ( keys[keyConfig.W] ? -1 : 0 ) + ( keys[keyConfig.S] ? 1 : 0 ) ) * playerSpeed;

				player.x += vx;
				player.y += vy;
			}

			player.x = clamp(player.x, 0, canvas.width - 8);
			player.y = clamp(player.y, 0, canvas.height - 8);

			playerCrosshair.x = player.x;
			playerCrosshair.y = player.y - 48;

			if ( state != 1 ) {
				let dx = menuPosPoint.x - player.x;
				let dy = menuPosPoint.y - player.y;
				let angle = Math.atan2(dy, dx);
				player.velX = 0.5 * Math.cos( angle );
				player.velY = 0.5 * Math.sin( angle );

				if ( dist( player.x, player.y, menuPosPoint.x, menuPosPoint.y ) < 8 ) {
					menuPosPoint = {
						x: rint(0, canvas.width - 16),
						y: rint(128, 200)
					};
				}
			}

			if ( lasers > 0 ) {
				if ( ( ( keys[keyConfig.PFIRE] ) || forcePrimaryFire ) && lasersTick >= lasersDelay ) {
					let fireDefault = true;
					if ( pslotItem != null ) {
						if ( pslotItem.img.name == 'pu_fireball' ) {
							for ( let i = -1; i <= 1; i++ ) {
								let velX = i * 1.5;

								let fireball = spr({
									img: imgs.fireball,
									x: player.x - 8,
									y: player.y,
									velX: velX,
									velY: -2,
									power: 3,
									animTick: 0,
									animDelay: 15
								});
								projs.push( fireball );
							}

							lasers -= 3;

							fireDefault = false;
						}
					}

					if ( fireDefault ) {
						let laser = spr({
							img: imgs.plzr,
							x: player.x - 2,
							y: player.y,
							scale: 2,
							velY: -3,
							power: 1
						});
						projs.push( laser );

						lasers--;
					}

					lasersTick = 0;
				}
			}

			lasersTick++;


			if ( bombs > 0 ) {
				if ( ( ( keys[keyConfig.SFIRE] ) || forceSecondaryFire ) && bombsTick >= bombsDelay ) {
					let bomb = spr({
						img: imgs.bomb,
						x: player.x - 2,
						y: player.y,
						scale: 2,
						velY: -0.75,
						groundProj: true,
						power: 1
					});
					projs.push( bomb );
					bombs--;

					bombsTick = 0;
				}
			}

			bombsTick++;
		}
		else {
			playerCrosshair.vis = false;
		}
		

		if ( bombs > 0 ) {
			playerCrosshair.frame = 0;
		}
		else {
			playerCrosshair.frame = 1;
		}

		if ( elapsed % 64 == 0 ) {
			for ( let x = 0; x < 14; x++ ) {
				generateTile( x, -2, x, currentGeneratedY );
			}
			surfaceZoom -= 0.1;
			currentGeneratedY--;

			if ( currentGeneratedY < -100 && stage == 0 ) {
				stage = 1;
			}

			if ( currentGeneratedY < -200 && stage == 1 ) {
				stage = 2;
			}

			if ( currentGeneratedY < -210 && stage == 2 ) {
				canNaturalSpawn = false;
				canSpawnBoss = true;
			}
			console.log(canSpawnBoss, hasSpawnedBoss, currentGeneratedY);
		}

		if ( canNaturalSpawn ) {
			let droneWaveTimer = 120;
			if ( stage == 1 ) {
				droneWaveTimer += 100;
			}
			else if ( stage == 2 ) {
				droneWaveTimer += 200;
			}

			if ( elapsed % droneWaveTimer == 0 ) {
				let droneX = rint(0, canvas.width - 16);

				let droneType = stage == 0 ? 'drone' : 'drone_armored';
				let droneHp = droneType == 'drone' ? 1 : 3;

				for ( let i = 0; i < rint(1, 3); i++ ) {
					let drone = new Drone({
						plyr: player,
						type: droneType,
						x: droneX + rint(-8, 8),
						y: -32 - rint(-8, 8),
						img: imgs[droneType],
						frame: 0,
						hp: droneHp,
						power: 1,
						points: 10
					});
					drone.isPlaying = false;
					drone.velY = rint(0.5, 1);
					drone.velX = rf(-0.5, 0.5);

					enemies.push(drone);
				}
			}

			if ( currentGeneratedY < -30 ) {
				if ( elapsed % 300 == 0 ) {
					let spinner = new Spinner({
						plyr: player,
						type: 'spinner',
						x: rint(0, canvas.width),
						y: -32,
						img: imgs.spinner,
						hp: 1,
						power: 1,
						points: 50
					});
					spinner.angle += 1;
					spinner.velY = rint(1.5, 3);

					enemies.push(spinner);
				}
			}
		}

		if ( canSpawnBoss && ! hasSpawnedBoss ) {
			switch ( stage ) {
				case 2: {
					let baddie = new BigBaddie({
						plyr: player,
						type: 'big_baddie',
						x: canvas.width/2,
						y: -144,
						origin: { x: 112/2, y: 144/2 },
						img: imgs.big_baddie,
						hp: 300,
						power: 1,
						points: 5000,
						canCull: false
					});
					baddie.onDestroy = () => {
						let store = JSON.parse( localStorage.getItem( 'stella_proelium' ) );
						store = ( store != undefined && store != null ) ? store : {};
						store.highscores = store.highscores != undefined ? store.highscores : [];
		
						store.highscores.push( score );
						
						store.highscores.sort((a, b) => b - a);
						localStorage.setItem( 'stella_proelium', JSON.stringify( store ) );
		

						state = 0;

						reset( {
							type: 'hard'
						} );
					};

					enemies.push( baddie );

					break;
				}
			}

			canSpawnBoss = false;
			hasSpawnedBoss = true;
		}


		for ( let i = 0; i < tiles.length; i++ ) {
			tiles[i].y += 0.25;
		}
		tileMoveDelta += 0.25;

		if ( tileMoveDelta % 0.25 == 1 ) {
			tileMoveDelta = 0;
		}
		


		elapsed++;
	}

	function render() {
		ctx.clearRect(0, 0, canvas.width, canvas.height);
		rect( ctx, 0, 0, canvas.width, canvas.height, hues.RD );

		// render the rest
		for ( let i = 0; i < tiles.length; i++ ) {
			let tile = tiles[i];

			if ( tile.depth == 0 ) {
				tile.render( ctx );
			}
		}

		for ( let i = 0; i < tiles.length; i++ ) {
			let tile = tiles[i];

			if ( tile.depth == 1 ) {
				if ( tile.type == 'gaa' ||
					tile.type == 'gaa_armored' ) {
					if ( tile.frame == 0 ) {
						tile.canShoot = true;
					}
	
					if ( tile.frame == 2 && tile.canShoot ) {
						let bullet = spr({
							img: imgs.gaa_bullet,
							x: tile.x + 8,
							y: tile.y + 8,
							animTick: 0,
							animDelay: 10,
							isFriendly: false,
							power: 1
						});

						let dx = player.x - bullet.x;
						let dy = player.y - bullet.y;
						let angle = Math.atan2(dy, dx);
						bullet.velX = 0.5 * Math.cos( angle );
						bullet.velY = 0.5 * Math.sin( angle );
						
						projs.push( bullet );
	
						tile.canShoot = false;
					}
				}

				tile.render( ctx );
			}

			if ( cull( tile ) ) {
				tile.destr = true;
			}

			if ( tile.destr ) {
				tiles.splice( i, 1 );
				i--;
			}
		}

		for ( let i = 0; i < parts.length; i++ ) {
			let part = parts[i];

			part.render( ctx );

			part.y -= part.speed;

			if ( cull( part ) ) {
				part.destr = true;
			}

			if ( part.destr ) {
				parts.splice( i, 1 );
				i--;
			}
		}

		for ( let i = 0; i < projs.length; i++ ) {
			let proj = projs[i];

			proj.render( ctx );

			if ( proj.img.name == 'bomb' ) {
				if ( proj.scaleX > 0.3 ) {
					proj.scaleX -= 0.03;
					proj.scaleY -= 0.03;
					proj.perceivedHeight -= 1;
					proj.x += 0.006;
					proj.velY += 0.01;
				}
				else {
					let tilesBombed = [];

					for ( let j = 0; j < tiles.length; j++ ) {
						let tj = tiles[j];

						let craterRect = {
							x: proj.x - 6,
							y: proj.y - 6,
							dw: 12,
							dh: 12
						};

						if ( tj.img.name != 'stars' ) {
							if ( collision( craterRect, tj ) && tj.depth == 1 ) {
								tilesBombed.push(tj);

								damage( tj, proj );

								if ( tj.destr ) {
									score += tj.points;
								}
							}
						}
					}

					for ( let i = 0; i < tilesBombed.length; i++ ) {
						let tileBombed = tilesBombed[i];

						let crater = spr({
							img: imgs.crater,
							x: tileBombed.x,
							y: tileBombed.y,
							frame: rint(0, 3),
							animTick: 0,
							animDelay: 30
						} );
						tiles.push(crater);

						for ( let i = 0; i < 100; i++ ) {
							let fireImgs = [
								'smoke',
								'fire'
							];
							let fireImg = imgs[fireImgs[rint(0, fireImgs.length - 1)]];

							let fire = spr({
								img: fireImg,
								x: tileBombed.x + rint(4, 12),
								y: tileBombed.y + rint(4, 12),
								life: rint(300, 600)
							});
							parts.push( fire );
						}
					}

					proj.destr = true;
				}
			}

			if ( cull( proj ) ) {
				proj.destr = true;
			}

			if ( proj.destr ) {
				if ( proj.img.name == 'plzr'
					|| proj.img.name == 'fireball' ) {
					lasers++;
				}

				if ( proj.img.name == 'bomb' ) {
					bombs++;
				}

				projs.splice( i, 1 );
				i--;
			}
		}

		for ( let i = 0; i < consumables.length; i++ ) {
			let consumable = consumables[i];

			consumable.render( ctx );

			if ( collision( player, consumable ) ) {
				changeItem( consumable.img.name );

				consumable.destr = true;
			}

			if ( cull( consumable ) ) {
				consumable.destr = true;
			}

			if ( consumable.destr ) {
				consumables.splice( i, 1 );
				i--;
			}
		}


		playerCrosshair.render( ctx );
		player.render( ctx );

		for ( let i = 0; i < enemies.length; i++ ) {
			let enemy = enemies[i];

			enemy.render( ctx );

			if ( enemy.type == 'gaa' ||
			enemy.type == 'gaa_armored' ) {
			if ( enemy.frame == 0 ) {
				enemy.canShoot = true;
			}

				if ( enemy.frame == 2 && enemy.canShoot ) {
					let bullet = spr({
						img: imgs.gaa_bullet,
						x: enemy.x + 8,
						y: enemy.y + 8,
						animTick: 0,
						animDelay: 10,
						isFriendly: false,
						power: 1
					});

					let dx = player.x - bullet.x;
					let dy = player.y - bullet.y;
					let angle = Math.atan2(dy, dx);
					bullet.velX = 0.5 * Math.cos( angle );
					bullet.velY = 0.5 * Math.sin( angle );
					
					projs.push( bullet );

					enemy.canShoot = false;
				}
			}

			if ( enemy.type == 'big_baddie' ) {
				if ( enemy.canSpawnGun && ! enemy.hasSpawnedGun ) {
					let gx = enemy.x - 24;
					let gy = enemy.y - 24;

					let hub = new GAA_Large_Hub({
						plyr: player,
						type: 'gaa_large_hub_armored',
						x: gx,
						y: gy,
						img: imgs.gaa_large_hub_armored,
						animTick: 0,
						animDelay: 7,
						depth: 0,
						hp: 9999
					});
					enemies.push(hub);

					
					for ( let ax = -2; ax <= 2; ax++ ) {
						for ( let ay = -2; ay <= 2; ay++ ) {
							if ( ( ( ax == 0 && ay != 0 ) || ( ay == 0 && ax != 0 ) ) &&
								( ax != -1 && ax != 1 && ay != -1 && ay != 1 ) ) {
								let gaa = new GAA({
									plyr: player,
									type: 'gaa_armored',
									x: (gx + 16) + (ax * 16),
									y: (gy + 16) + (ay * 16),
									img: imgs.gaa_armored,
									animTick: 0,
									animDelay: 3,
									depth: 1,
									hp: 9999,
									points: 75
								});
								hub.buildings.push(gaa);
								enemies.push(gaa);
							}
						}
					}

					enemy.canSpawnGun = false;
					enemy.hasSpawnedGun = true;
				}
			}

			if ( enemy.canCull && cull( enemy ) ) {
				enemy.destr = true;
			}

			for ( let j = 0; j < projs.length; j++ ) {
				let proj = projs[j];

				if ( proj.isFriendly && ! proj.groundProj ) {
					if ( collision( proj, enemy ) ) {
						damage( enemy, proj );

						for ( let i = 0; i < 50; i++ ) {
							let fireImgs = [
								'smoke',
								'fire'
							];
							let fireImg = imgs[fireImgs[rint(0, fireImgs.length - 1)]];
	
							let fire = spr({
								img: fireImg,
								x: enemy.x + rint(0, 8),
								y: enemy.y + rint(0, 8),
								life: rint(1, 5)
							});
							parts.push( fire );
						}

						if ( enemy.destr ) {
							if ( enemy.points > 0 ) {
								score += enemy.points;
							}

							if ( rint( 0, 1000 ) > 970 ) {
								let puFire = new Consumable( {
									img: imgs.pu_fireball,
									x: enemy.x,
									y: enemy.y,
									animTick: 0,
									animDelay: 6
								} );
								puFire.velY = 0.25;
								consumables.push( puFire );
							}
						}

						proj.destr = true;
					}
				}

				if ( ! proj.isFriendly ) {
					if ( collision( player, proj ) ) {
						damage( player, proj );

						proj.destr = true;
					}
				}
			}

			if ( state != 1 ) {
				if ( dist( player.x, player.y, enemy.x, enemy.y ) < 64 ) {
					if ( enemy.y < player.y ) {
						forcePrimaryFire = true;
					}
				}
			}

			if ( collision( player, enemy ) ) {
				damage( player, enemy );
			}

			if ( enemy.destr ) {
				enemies.splice( i, 1 );
				i--;
			}
		}

		if ( player.destr ) {
			player.vis = false;
		}


		if ( state == 0 ) {
			drawText( ctx, 8, 8, 'STELLA', 9 );
			drawText( ctx, 12, 64, 'PROELIUM', 6 );
			drawText( ctx, 20, 106, 'DEVELOPED BY JARED YORK', 2 );

			drawText( ctx, 4, 270, 'MADE WITH <3 FOR JS13K 2021', 2 );


			for ( let i = 0; i < mainMenuOptions.length; i++ ) {
				let option = mainMenuOptions[i];

				drawText( ctx, 48, 200 + (i * 32), option, 3 );

				if ( mainMenuOptionSelected == i ) {
					rect( ctx, 48, 200 + 18 + (i * 32), 200, 2, hues.WHT );
				}
			}
		}
		else if ( state === 1 ) {
			if ( pslotItem ) {
				pslotItem.render( ctx );
			}
			pslot.render( ctx );

			if ( hasPowerUp ) {
				let puLifeLeftPerc = ( puTimeLeft / consumableItems[pslotItem.img.name].life );
				
				let puLifeHue = hues.GRN;

				if ( puLifeLeftPerc < 0.4 ) {
					puLifeHue = hues.CLAY;
				}
				else if ( puLifeLeftPerc < 0.6 ) {
					puLifeHue = hues.LIME;
				}

				rect( ctx, pslotItem.x, pslotItem.y - 8, pslotItem.dw, 8, hues.BK );
				rect( ctx, pslotItem.x + 2, pslotItem.y - 6, Math.round( puLifeLeftPerc * (pslotItem.dw - 4) ), 4, puLifeHue );
			}




			for ( let i = 0; i < lives; i++ ) {
				ctx.drawImage( imgs.plyr.dyntexes[0].shadCanv, 8 + (i * 16 + 2), 34 );
				ctx.drawImage( imgs.plyr.dyntexes[0].canv, 8 + (i * 16 + 2), 32 );
			}

			drawText( ctx, 8, 8, String(score), 3 );
		}
		else if ( state == 2 ) {
			drawText( ctx, 28, 24, 'HIGH SCORES', 4 );

			let store = JSON.parse( localStorage.getItem( 'stella_proelium' ) );
			store = ( store != undefined && store != null ) ? store : {};
			store.highscores = store.highscores !== undefined ? store.highscores : [];

			if ( store.highscores.length > 0 ) {
				for ( let i = 0; i < store.highscores.length; i++ ) {
					if ( i < 5 ) {
						drawText( ctx, 28, 64 + ( i * 20 ), ( i + 1 ) + '. ' + store.highscores[i], 2 );
					}
				}
			}
			else {
				drawText( ctx, 45, 64, 'NO HIGH SCORES YET', 2 );
			}


			for ( let i = 0; i < highScoreOptions.length; i++ ) {
				let option = highScoreOptions[i];

				drawText( ctx, 48, 200 + (i * 32), option, 3 );

				if ( highScoreOptionSelected == i ) {
					rect( ctx, 48, 200 + 18 + (i * 32), 200, 2, hues.WHT );
				}
			}
		}
		else if ( state == 3 ) {
			drawText( ctx, 28, 24, 'ARE YOU SURE', 4 );

			for ( let i = 0; i < highScoreConfirmationOptions.length; i++ ) {
				let option = highScoreConfirmationOptions[i];

				drawText( ctx, 48, 200 + (i * 32), option, 3 );

				if ( highScoreConfirmationOptionSelected == i ) {
					rect( ctx, 48, 200 + 18 + (i * 32), 200, 2, hues.WHT );
				}
			}
		}


	}

	function generateTile(x, y, perX, perY) {
		noise.seed( stageSeeds[stage] );

		let perlin = noise.perlin2( perX / surfaceZoom, perY / surfaceZoom );

		switch ( stage ) {
			case 0: {
				let frame = 0;

				if ( perlin < -0.01 && perlin > -0.15 ) {
					frame = 1;
				}
				else if (perlin <= -0.15 && perlin > -0.35) {
					frame = 2;
				}
				else if (perlin <= -0.3) {
					frame = 3;
				}

				let t = null;
				if ( perlin > -0.4 ) {
					t = spr({
						img: imgs.gpl,
						x: x * 16,
						y: y * 16,
						frame: frame
					});
					t.isPlaying = false;
				}
				else {
					t = spr({
						img: imgs.water,
						x: x * 16,
						y: y * 16,
						frame: frame,
						animTick: rint(0, 60),
						animDelay: 120
					});
					t.isPlaying = true;
				}
				tiles.push(t);

				if ( perlin <= -(0.15 + ( ( currentGeneratedY ) * 0.000002 ) ) && perlin >= -0.151 && canNaturalSpawn ) {
					if ( rint(0, 100) > 50 ) {
						gaa = new GAA({
							plyr: player,
							type: 'gaa',
							x: x * 16,
							y: y * 16,
							img: imgs.gaa,
							animTick: 0,
							animDelay: 7,
							depth: 1,
							hp: 1,
							points: 75
						});
						tiles.push(gaa);

						for ( let ax = -1; ax <= 1; ax++ ) {
							for ( let ay = -1; ay <= 1; ay++ ) {
								if ( ax != 0 && ay != 0 ) {
									let garmor = spr({
										plyr: player,
										type: 'garmor',
										x: (x * 16) + (ax * 16),
										y: (y * 16) + (ay * 16),
										img: imgs.garmor,
										depth: 1,
										hp: 1,
										points: 150
									});
									tiles.push(garmor);
								}
							}
						}
					}
					else {
						let hub = new GAA_Large_Hub({
							plyr: player,
							type: 'gaa_large_hub',
							x: x,
							y: y,
							img: imgs.gaa_large_hub,
							animTick: 0,
							animDelay: 7,
							depth: 0
						});
						tiles.push(hub);

						let dome = spr({
							plyr: player,
							type: 'gaa_large_dome',
							x: x + 16,
							y: y + 16,
							img: imgs.gaa_large_dome,
							depth: 1,
							hp: 1,
							points: 1000
						});
						dome.onDestroy = () => {
							hub.buildings.forEach( ( building ) => {
								let crater = spr({
									img: imgs.crater,
									x: building.x,
									y: building.y,
									frame: rint(0, 3),
									animTick: 0,
									animDelay: 30
								} );
								tiles.push(crater);
		
								for ( let i = 0; i < 100; i++ ) {
									let fireImgs = [
										'smoke',
										'fire'
									];
									let fireImg = imgs[fireImgs[rint(0, fireImgs.length - 1)]];
		
									let fire = spr({
										img: fireImg,
										x: building.x + rint(4, 12),
										y: building.y + rint(4, 12),
										life: rint(300, 600)
									});
									parts.push( fire );
								}

								building.destr = true;
							} );
						};
						hub.buildings.push(dome);
						tiles.push(dome);

						
						for ( let ax = -2; ax <= 2; ax++ ) {
							for ( let ay = -2; ay <= 2; ay++ ) {
								if ( ( ( ax == 0 && ay != 0 ) || ( ay == 0 && ax != 0 ) ) &&
									( ax != -1 && ax != 1 && ay != -1 && ay != 1 ) ) {
									let gaa = new GAA({
										plyr: player,
										type: 'gaa',
										x: (x + 16) + (ax * 16),
										y: (y + 16) + (ay * 16),
										img: imgs.gaa,
										animTick: 0,
										animDelay: 3,
										depth: 1,
										hp: 1,
										points: 75
									});
									hub.buildings.push(gaa);
									tiles.push(gaa);
								}
							}
						}
					}
				}

				break;
			}

			case 1: {
				let frame = 0;

				if ( perlin < -0.01 && perlin > -0.15 ) {
					frame = 1;
				}
				else if (perlin <= -0.15 && perlin > -0.35) {
					frame = 2;
				}
				else if (perlin <= -0.3) {
					frame = 3;
				}

				let t = null;
				if ( perlin > -0.4 ) {
					t = spr({
						img: imgs.molt,
						x: x * 16,
						y: y * 16,
						frame: frame
					});
					t.isPlaying = false;
				}
				else {
					t = spr({
						img: imgs.lava,
						x: x * 16,
						y: y * 16,
						frame: frame,
						animTick: rint(0, 96),
						animDelay: 96
					});
				}
				tiles.push(t);

				if ( perlin <= -(0.15 + ( ( currentGeneratedY ) * 0.000002 ) ) && perlin >= -0.151 && canNaturalSpawn) {
					if ( rint(0, 100) > 50 ) {
						gaa = new GAA({
							plyr: player,
							type: 'gaa_armored',
							x: x * 16,
							y: y * 16,
							img: imgs.gaa_armored,
							animTick: 0,
							animDelay: 7,
							depth: 1,
							hp: 1,
							points: 75
						});
						tiles.push(gaa);

						for ( let ax = -1; ax <= 1; ax++ ) {
							for ( let ay = -1; ay <= 1; ay++ ) {
								if ( ax != 0 && ay != 0 ) {
									let garmor = spr({
										plyr: player,
										type: 'garmor_strong',
										x: (x * 16) + (ax * 16),
										y: (y * 16) + (ay * 16),
										img: imgs.garmor_strong,
										depth: 1,
										hp: 1,
										points: 150
									});
									tiles.push(garmor);
								}
							}
						}
					}
					else {
						let hub = new GAA_Large_Hub({
							plyr: player,
							type: 'gaa_large_hub_armored',
							x: x,
							y: y,
							img: imgs.gaa_large_hub_armored,
							animTick: 0,
							animDelay: 7,
							depth: 0,
							hp: 2
						});
						tiles.push(hub);

						let dome = spr({
							plyr: player,
							type: 'gaa_large_dome',
							x: x + 16,
							y: y + 16,
							img: imgs.gaa_large_dome,
							depth: 1,
							hp: 1,
							points: 1000
						});
						dome.onDestroy = () => {
							hub.buildings.forEach( ( building ) => {
								let crater = spr({
									img: imgs.crater,
									x: building.x,
									y: building.y,
									frame: rint(0, 3),
									animTick: 0,
									animDelay: 30
								} );
								tiles.push(crater);
		
								for ( let i = 0; i < 100; i++ ) {
									let fireImgs = [
										'smoke',
										'fire'
									];
									let fireImg = imgs[fireImgs[rint(0, fireImgs.length - 1)]];
		
									let fire = spr({
										img: fireImg,
										x: building.x + rint(4, 12),
										y: building.y + rint(4, 12),
										life: rint(300, 600)
									});
									parts.push( fire );
								}

								building.destr = true;
							} );
						};
						hub.buildings.push(dome);
						tiles.push(dome);

						
						for ( let ax = -2; ax <= 2; ax++ ) {
							for ( let ay = -2; ay <= 2; ay++ ) {
								if ( ( ( ax == 0 && ay != 0 ) || ( ay == 0 && ax != 0 ) ) &&
									( ax != -1 && ax != 1 && ay != -1 && ay != 1 ) ) {
									let gaa = new GAA({
										plyr: player,
										type: 'gaa_armored',
										x: (x + 16) + (ax * 16),
										y: (y + 16) + (ay * 16),
										img: imgs.gaa_armored,
										animTick: 0,
										animDelay: 3,
										depth: 1,
										hp: 1,
										points: 75
									});
									hub.buildings.push(gaa);
									tiles.push(gaa);
								}
							}
						}
					}
				}


				break;
			}

			case 2: {
				let frame = rint(0, 3);

				let t = spr({
					img: imgs.stars,
					x: x * 16,
					y: y * 16,
					frame: frame,
					animTick: rint(0, 500),
					animDelay: 500
				});
				t.isPlaying = true;

				tiles.push(t);

				break;
			}
		}
	}

	function loadContent() {
		let data = {};

		data.hues = {
			BK: '#000000',
			WHT: '#ffffff',
			RD: '#883932',
			CYAN: '#67b6bd',
			MAG: '#8b3f96',
			GRN: '#55a049',
			PURP: '#40318d',
			LIME: '#bfce72',
			BWN: '#8b5429',
			DK_BWN: '#574200',
			CLAY: '#b86962',
			DK_GRY: '#505050',
			GRY: '#787878',
			LIME2: '#94e089',
			BLU: '#7869c4',
			LT_GRY: '#9f9f9f'
		};

		let hues = data.hues;

		let palCanv = mkcanv( 8 * Object.keys( data.hues ).length, 8, { appendDOM: true } );
		let palCtx = palCanv.getContext( '2d' );
		let h = 0;
		for ( const property in data.hues ) {
			rect(palCtx, h * 8, 0, 8, 8, data.hues[property] );
			h++;
		}
	
	
		// load assets
		let imgs = {
			s16x16: {
				name: 's16x16',
				dynrender: {
					w: 16,
					h: 16,
					v: 1,
					render: ( ctx ) => {
						rect( ctx, 0, 0, 16, 16, hues.WHT );
					}
				}
			},
			plyr: {
				name: 'plyr',
				dynrender: {
					w: 16,
					h: 16,
					v: 1,
					hs: true,
					ent: true,
					render: ( ctx ) => {
						let size = 16;
	
						// left front wing
						drawTri(
							ctx,
							[
								{ x: size * 0.5, y: size * 0.1 },
								{ x: size * 0.25, y: size * 0.25 },
								{ x: size * 0.5, y: size * 0.5 }
							],
							hues.GRY
						);
	
						// right front wing
						drawTri(
							ctx,
							[
								{ x: size * 0.5, y: size * 0.1 },
								{ x: size * 0.75, y: size * 0.25 },
								{ x: size * 0.5, y: size * 0.5 }
							],
							hues.LT_GRY
						);
	
						// left main wing
						drawTri(
							ctx,
							[
								{ x: size * 0.5, y: size * 0.5 },
								{ x: 0, y: size * 0.75 },
								{ x: size * 0.5, y: size }
							],
							hues.GRY
						);
	
						// right main wing
						drawTri(
							ctx,
							[
								{ x: size * 0.5, y: size * 0.5 },
								{ x: size, y: size * 0.75 },
								{ x: size * 0.5, y: size }
							],
							hues.LT_GRY
						);
	
						// main body
						drawTri(
							ctx,
							[
								{ x: size * 0.5, y: 0 },
								{ x: size * 0.75, y: size },
								{ x: size * 0.25, y: size }
							],
							hues.GRY
						);
	
						drawTri(
							ctx,
							[
								{ x: size * 0.5, y: 0 },
								{ x: size * 0.75, y: size },
								{ x: size * 0.55, y: size }
							],
							hues.LT_GRY
						);
	
						// cockpit
						circle(
							ctx,
							size * 0.5,
							size * 0.35,
							size * 0.075,
							hues.CYAN
						);
					}
				}
			},
			plzr: {
				name: 'plzr',
				dynrender: {
					w: 2,
					h: 4,
					bg: hues.CYAN,
					v: 1,
					render: () => {}
				}
			},
			fireball: {
				name: 'fireball',
				frames: 1,
				dynrender: {
					w: 16,
					h: 16,
					render: ( ctx ) => {
						let size = 16;

						circle( ctx, size/2, size/2, size/2, hues.WHT, hues.LIME, 2 );
					}
				}
			},
			bomb: {
				name: 'bomb',
				dynrender: {
					w: 2,
					h: 4,
					bg: hues.DK_GRY,
					v: 1,
					hs: true,
					render: () => {}
				}
			},
			crosshair: {
				name: 'crosshair',
				dynrender: {
					w: 32,
					h: 16,
					v: 1,
					render: function ( ctx ) {
						let ts = 16;
						for ( let i = 0; i < 2; i++ ) {
							for ( let x = i * ts; x < (i * ts) + ts; x++ ) {
								for ( let y = 0; y < ts; y++ ) {
									let halfWidth = ( i * ts ) + ( ts * 0.5 );
	
									let canDraw = false;
									if ( i == 0 ) {
										if ( x % 15 == 0 || y % 15 == 0 ) {
											canDraw = true;
										}
									}
	
									if ( ( ( x == halfWidth - 1 || x == halfWidth ) && ( y % 2 == 0 ) ) ||
										   ( y == 7 || y == 8 ) && ( ( y == 7 || y == 8 ) && ( x % 2 == 0 ) ) ) {
										canDraw = true;
									}
	
									if ( canDraw ) {
										pen( ctx, x, y, hues.WHT );
									}
								}
							}
						}
					}
				},
				frames: 2,
				anim: true,
				fw: 16,
				fh: 16
			},
			crater: {
				name: 'crater',
				dynrender: {
					w: 64,
					h: 16,
					v: 5,
					render: function( ctx ) {
						let size = 16;
	
						for ( let i = 0; i < 4; i++ ) {
							circle(
								ctx,
								((i + 0.5) * 2) * ( size * 0.5 ),
								size * 0.5,
								size * 0.5,
								hues.BK,
								hues.DK_GRY,
								1
							);
	
							let pitColor = (i == 0 || i == 1) ? hues.DK_GRY : hues.RD;
	
							circle(
								ctx,
								((i + 0.5) * 2) * ( size * 0.5 ),
								size * 0.5,
								size * 0.25,
								pitColor
							);
						}

						for ( let i = 0; i < 80; i++ ) {
							if ( rint(0, 100) > 80 ) {
								pen( ctx, rint(0, 64), rint(0, 16), hues.CLAY );
							}
						}
					}
				},
				frames: 4,
				anim: true,
				fw: 16,
				fh: 16
			},
			gpl: {
				name: 'gpl',
				dynrender: {
					w: 64,
					h: 16,
					bg: hues.DK_BWN,
					v: 5,
					render: function ( ctx ) {
						let ts = 16;
						for ( let x = 0; x < ts * 4; x++ ) {
							for ( let y = 0; y < ts; y++ ) {
								if ( x < ts ) {
									for ( let i = 0; i < rint(0, 1); i++ ) {
										let rw = rint(2, 5);
										let rh = rint(2, 3);
										
										let rx = x > rw * 0.5 && x < ( ts * 4 ) - ( rw * 0.5 ) ? x + rint(rw * 0.5, ts - (rw * 0.5)) : rw * 0.5;
										let ry = y > rh * 0.5 && y < ( ts ) - ( rh * 0.5) ? y + rint(rh * 0.5, ts - (rh * 0.5)) : rh * 0.5;
		
										ctx.fillStyle = hues.DK_BWN;
										ctx.beginPath();
										ctx.ellipse(
											rx - 1,
											ry + 1,
											rw,
											rh,
											Math.PI / 4,
											0,
											2 * Math.PI
										);
										ctx.fill();
		
										ctx.fillStyle = hues.GRN;
										ctx.beginPath();
										ctx.ellipse(
											rx,
											ry,
											rw,
											rh,
											Math.PI / 4,
											0,
											2 * Math.PI
										);
										ctx.fill();
									}
	
									if ( x % 2 == 0 && y % 2 == 1 ) {									
										pen( ctx, x, y, hues.DK_BWN );
									}
	
									if ( x % 4 == 0 && y % 4 == 1 ) {
										if ( rint(0, 10) > 3 ) {							
											pen( ctx, x, y, hues.LIME );
										}
									}
								}
								else if ( x >= ts && x < ts * 3 ) {
									pen( ctx, x, y, hues.GRN );
	
									if ( rint(0, 500) == 1 ) {
										pen( ctx, x, y, hues.LIME );
									}
								}
								else {
									rect( ctx, x, y, ts, ts, hues.LIME );
								}
							}
						}
					}
				},
				anim: true,
				fw: 16,
				fh: 16
			},
			molt: {
				name: 'molt',
				template: 'gpl',
				dynrender: {
					palshift: [
						[hues.DK_BWN, hues.RD],
						[hues.GRN, hues.BK],
						[hues.LIME, hues.DK_GRY]
					]
				}
			},
			water: {
				name: 'water',
				dynrender: {
					w: 64,
					h: 16,
					bg: hues.PURP,
					v: 1,
					render: function ( ctx ) {
						let ts = 16;
						for ( let i = 0; i < 16; i++ ) {
							pen(ctx, rint(0, 64), rint(0, 16), hues.CYAN);
						}
					}
				},
				frames: 4,
				anim: true,
				fw: 16,
				fh: 16
			},
			lava: {
				name: 'lava',
				template: 'water',
				dynrender: {
					palshift: [
						[ hues.PURP, hues.RD ],
						[ hues.CYAN, hues.LIME ]
					]
				}
			},
			ice: {
				name: 'ice',
				template: 'water',
				dynrender: {
					palshift: [
						[ hues.PURP, hues.CYAN ],
					]
				}
			},
			stars: {
				name: 'stars',
				template: 'water',
				dynrender: {
					palshift: [
						[ hues.PURP, hues.BK ],
						[ hues.CYAN, hues.LT_GRY ]
					]
				}
			},
			drone: {
				name: 'drone',
				dynrender: {
					w: 32,
					h: 16,
					v: 1,
					hs: true,
					ent: true,
					render: function( ctx ) {
						let size = 16;
	
						for ( let i = 0; i < 2; i++ ) {
							circle(
								ctx,
								((i + 0.5) * 2) * ( size * 0.5 ),
								size * 0.5,
								size * 0.5,
								hues.GRY,
								hues.LT_GRY,
								1
							);
	
							let cockpitColor = i == 0 ? hues.RD : hues.CLAY;
							let cockpitShine = i == 0 ? hues.CLAY : hues.LIME;
	
							circle(
								ctx,
								((i + 0.5) * 2) * ( size * 0.5 ),
								size * 0.5,
								size * 0.25,
								cockpitColor
							);
	
							circle(
								ctx,
								((i + 0.5) * 2 ) * ( size * 0.55 ),
								size * 0.45,
								size * 0.015,
								cockpitShine
							);
						}
					}
				},
				anim: true,
				frames: 2,
				fw: 16,
				fh: 16
			},
			drone_armored: {
				name: 'drone_armored',
				template: 'drone',
				dynrender: {
					palshift: [
						[ hues.GRY, hues.DK_GRY ],
						[ hues.LT_GRY, hues.GRY ],
					]
				}
			},
			spinner: {
				name: 'spinner',
				dynrender: {
					w: 16,
					h: 16,
					hs: true,
					v: 5,
					ent: true,
					render: (ctx) => {
						size = 128;
	
						var hueKeys = Object.keys(hues);
						let hue = hues[hueKeys[ hueKeys.length * Math.random() << 0]];
	
						rect(ctx, 0, 0, size, size, hue);
					}
				},
			},
			garmor: {
				name: 'garmor',
				dynrender: {
					w: 16,
					h: 16,
					v: 1,
					bg: hues.CYAN,
					ent: true,
					render: (ctx) => {
						let size = 16;
	
						// left
						drawTri(
							ctx,
							[
								{ x: 0, y: 0 },
								{ x: size * 0.5, y: size * 0.5 },
								{ x: size * 0, y: size }
							],
							hues.DK_GRY
						);
	
						// right
						drawTri(
							ctx,
							[
								{ x: size, y: 0 },
								{ x: size * 0.5, y: size * 0.5 },
								{ x: size, y: size }
							],
							hues.WHT
						);
					}
				},
			},
			garmor_strong: {
				name: 'garmor_strong',
				template: 'garmor',
				dynrender: {
					palshift: [
						[ hues.DK_GRY, hues.BK ],
						[ hues.GRY, hues.BK ],
						[ hues.CYAN, hues.DK_GRY ],
						[ hues.WHT, hues.GRY ]
					]
				}
			},
			gaa: {
				name: 'gaa', // AA
				anim: true,
				fw: 16,
				fh: 16,
				frames: 16,
				dynrender: {
					w: 256,
					h: 16,
					v: 1,
					bg: hues.CYAN,
					ent: true,
					render: ( ctx ) => {
						let size = 16;
	
						for ( let i = 0; i < 16; i++ ) {
							circle(ctx, ((i + 0.5) * 2) * ( size/2 ), size/2, size/2, hues.WHT);
	
							if ( i > 0 ) {
								circle(ctx, ((i + 0.5) * 2) * ( size/2 ), size/2, i * 2, hues.BK);
								circle(ctx, ((i + 0.5) * 2) * ( size/2 ), size/2, i * 1, hues.RD);
							}
						}
					}
				}
			},
			gaa_armored: {
				name: 'gaa_armored', // AA
				template: 'gaa',
				dynrender: {
					palshift: [
						[ hues.WHT, hues.DK_GRY ],
						[ hues.GRY, hues.BK ],
						[ hues.CYAN, hues.BK ],
						[ hues.RD, hues.PURP ]
					]
				}
			},
			gaa_bullet: {
				name: 'gaa_bullet', // AA
				anim: true,
				fw: 8,
				fh: 8,
				frames: 2,
				dynrender: {
					w: 16,
					h: 8,
					bg: hues.CYAN,
					render: ( ctx ) => {
						let size = 8;
	
						for ( let i = 0; i < 2; i++ ) {
							let col = i == 0 ? hues.WHT : hues.LIME;
							circle(ctx, ((i + 0.5) * 2) * ( size/2 ), size/2, size/2, col);
						}
					}
				}
			},
			gaa_large_hub: {
				name: 'gaa_large_hub',
				dynrender: {
					w: 48,
					h: 48,
					render: ( ctx ) => {
						rect( ctx, 16, 0, 16, 48, hues.LT_GRY );
						rect( ctx, 0, 16, 48, 16, hues.LT_GRY );

						circle( ctx, 24, 24, 24, hues.DK_GRY, hues.BK, 2 );
						circle( ctx, 48 * 0.51, 48 * 0.51, 20, hues.LT_GRY, hues.GRY, 4 );
						circle( ctx, 48 * 0.52, 48 * 0.52, 12, hues.WHT );
					}
				}
			},
			gaa_large_hub_armored: {
				name: 'gaa_large_hub_armored',
				template: 'gaa_large_hub',
				dynrender: {
					palshift: [
						[ hues.DK_GRY, hues.BK ],
						[ hues.GRY, hues.DK_GRY ],
						[ hues.LT_GRY, hues.GRY ],
						[ hues.WHT, hues.LT_GRY ],
					]
				}
			},
			gaa_large_dome: {
				name: 'gaa_large_dome',
				dynrender: {
					w: 16,
					h: 16,
					render: ( ctx ) => {
						circle( ctx, 8, 8, 8, hues.CYAN, hues.DK_GRY, 1 );
						circle( ctx, 9, 9, 3, hues.WHT, hues.LT_GRY, 1 );
					}
				}
			},
			big_baddie: {
				name: 'big_baddie',
				dynrender: {
					w: 112,
					h: 124,
					render: ( ctx ) => {
						let w = 112;
						let h = 124;

						// draw background
						drawTri(
							ctx, [
								{ x: 0, y: 16 },
								{ x: w, y: 16 },
								{ x: w/2, y: h }
							],
							hues.DK_GRY
						)

						rect( ctx, w*0.25, 0, 16, 16, hues.BK );
						rect( ctx, w*0.25, 8, 16, 16, hues.GRY );
						rect( ctx, w*0.25, 8, 16, 8, hues.WHT );


						rect( ctx, (w*0.75)-16, 0, 16, 16, hues.BK );
						rect( ctx, (w*0.75)-16, 8, 16, 16, hues.LT_GRY );
						rect( ctx, (w*0.75)-16, 8, 16, 8, hues.WHT );

						// draw lighter triangles
						drawTri(
							ctx,
							[
								{ x: 0, y: h/2 },
								{ x: w/2, y: 0 },
								{ x: w/2, y: h*0.75 }
							],
							hues.GRY
						);

						drawTri(
							ctx,
							[
								{ x: w, y: h/2 },
								{ x: w/2, y: 0 },
								{ x: w/2, y: h*0.75 }
							],
							hues.LT_GRY
						);
					}
				}
			},
			pu_fireball: {
				name: 'pu_fireball',
				dynrender: {
					w: 16,
					h: 16,
					render: ( ctx ) => {
						let size = 16;

						circle( ctx, size/2, size/2, size/2, hues.RD );

						circle( ctx, size/2, size/2, size/3, hues.CLAY );

						circle( ctx, size/2, size/2, size/6, hues.WHT );
					}
				}
			},
			pu_missile: {
				name: 'pu_missile',
				dynrender: {
					w: 16,
					h: 16,
					render: ( ctx ) => {
						let size = 16;

						rect( ctx, (size/2) - 4, 8, 4, 16, hues.LT_GRY );
					}
				}
			},
			smoke: {
				name: 'smoke',
				template: 's16x16',
				dynrender: {
					palshift: [
						[hues.WHT, hues.GRY]
					]
				}
			},
			fire: {
				name: 'fire',
				template: 's16x16',
				dynrender: {
					palshift: [
						[hues.WHT, hues.LIME]
					]
				}
			},
			pslot: {
				name: 'pslot',
				dynrender: {
					w: 24,
					h: 24,
					render: ( ctx ) => {
						let size = 24;

						rect( ctx, 0, 0, size, size, null, hues.WHT, 4 );
					}
				}
			}
		};
	
	
		let whitelistedKeys = [
			'name',
		];
	
		let iteration = 0;
		for ( const [imgKey, imgValue] of Object.entries( imgs ) ) {
			let img = imgValue;
	
			if ( img.template != undefined ) {
				// find template
				let templateFound = null;
				for ( const [ imgJKey, imgJValue ] of Object.entries( imgs ) ) {
					if ( imgJValue.name == img.template ) {
						templateFound = Object.assign( {}, imgJValue );
					}
				}
	
				let oldDynrenderArgs = img.dynrender;
	
				for ( const [key, value] of Object.entries( templateFound ) ) {
					if ( ! whitelistedKeys.includes( key ) ) {
						img[key] = value.valueOf();
					}
				}
	
				for ( const [daKey, daValue] of Object.entries( oldDynrenderArgs ) ) {
					img.dynrender[daKey] = daValue;
				}
			}
	
			img.dyntexes = [];
			img.dynrender.v = img.dynrender.v != undefined ? img.dynrender.v : 1;
			img.dynrender.hues = Object.assign( {}, hues );

			for ( let i = 0; i < img.dynrender.v; i++ ) {
				//console.log('generating ' + img.name );
				console.log(img.name);
				img.dyntexes.push( dyntex( img.dynrender ) );
				//console.log('finished generating ' + img.name );
				//console.log('');
			}

			iteration++;
			console.log('finished iteration ' + iteration + '/' + Object.entries( imgs ).length );
			console.log('');
		}

		data.imgs = imgs;
	
		return data;
	}

	function gameloop() {
		update();
		render();

		window.requestAnimationFrame( gameloop );
	}
} );

